package com.example.inventory.inventory_api;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class ProductService {

    // Inject the new ProductRepository to communicate with the database
    @Autowired
    private ProductRepository productRepository;

    // Creates and adds a new product to the database
    public Product createProduct(Product newProduct) {
        // ID is automatically generated by the JPA Entity on save
        return productRepository.save(newProduct);
    }

    // Retrieves all products
    public List<Product> getAllProducts() {
        return productRepository.findAll();
    }

    // Retrieves a single product by its ID (UUID is the correct type now)
    public Optional<Product> getProductById(String id) {
        try {
            UUID uuid = UUID.fromString(id);
            return productRepository.findById(uuid);
        } catch (IllegalArgumentException e) {
            return Optional.empty(); // Return empty if the ID string is not a valid UUID
        }
    }

    // Updates an existing product's details
    public Product updateProduct(Product updatedProduct) throws IllegalArgumentException {
        // We assume the ID has been set on updatedProduct by the Controller
        if (updatedProduct.getId() == null || !productRepository.existsById(updatedProduct.getId())) {
            return null; // Return null if product does not exist
        }
        if (updatedProduct.getStockQuantity() < 0) {
            throw new IllegalArgumentException("Stock quantity cannot be negative.");
        }
        // Save performs both insert (new product) and update (existing product)
        return productRepository.save(updatedProduct);
    }

    // Deletes a product by its ID
    public boolean deleteProduct(String id) {
        try {
            UUID uuid = UUID.fromString(id);
            if (productRepository.existsById(uuid)) {
                productRepository.deleteById(uuid);
                return true;
            }
            return false;
        } catch (IllegalArgumentException e) {
            return false;
        }
    }

    // Increases the stock quantity of a product
    public Product increaseStock(String id, int quantity) throws IllegalArgumentException {
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity to add must be positive.");
        }
        Optional<Product> productOptional = getProductById(id);

        if (productOptional.isPresent()) {
            Product product = productOptional.get();
            product.setStockQuantity(product.getStockQuantity() + quantity);
            return productRepository.save(product); // Save updated product to database
        }
        return null; // Product not found
    }

    // Decreases the stock quantity of a product
    public Product decreaseStock(String id, int quantity) throws IllegalArgumentException {
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity to remove must be positive.");
        }
        Optional<Product> productOptional = getProductById(id);

        if (productOptional.isPresent()) {
            Product product = productOptional.get();
            if (product.getStockQuantity() < quantity) {
                throw new IllegalArgumentException("Insufficient stock available for this product.");
            }
            product.setStockQuantity(product.getStockQuantity() - quantity);
            return productRepository.save(product); // Save updated product to database
        }
        return null; // Product not found
    }

    // Bonus feature: Lists all products with stock below their threshold
    public List<Product> getLowStockProducts() {
        return productRepository.findAll().stream()
                .filter(p -> p.getStockQuantity() <= p.getLowStockThreshold())
                .collect(Collectors.toList());
    }

    /**
     * Setter for productRepository, primarily used for injecting the dependency
     * in JUnit tests when not using the full Spring context.
     */
    public void setProductRepository(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }
}